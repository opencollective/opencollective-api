'use strict';

import { getRecreateViewsQuery } from './lib/views';

/**
 * This migration seeds default values for `createdAt` and `updatedAt` columns, and enforce non-nullability.
 * We're starting with `Users` and `Collectives` tables cause other tables will then use their values as default.
 */

/**
 * This table was generated by looking at the schema to see which tables have `createdAt` and `updatedAt` columns without a non-null constraint, then
 * running a SQL query to check if null values exist. See https://github.com/opencollective/opencollective-api/pull/9761#issuecomment-1920759364.
 */
const TABLES_TO_MIGRATE = [
  {
    name: 'Activities',
    hasNullCreatedAtValues: false, // Migrated manually
    hasNullUpdatedAtValues: false, // Migrated manually
    missingConstraints: ['createdAt'],
  },
  {
    name: 'Applications',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'Collectives',
    hasNullCreatedAtValues: false, // Migrated manually
    hasNullUpdatedAtValues: false, // Migrated manually
    missingConstraints: ['createdAt', 'updatedAt'],
    dependantViews: [{ name: 'CollectiveTagStats', isMaterialized: true }],
  },
  {
    name: 'Comments',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'ConnectedAccounts',
    hasNullCreatedAtValues: true,
    hasNullUpdatedAtValues: true,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'CurrencyExchangeRates',
    hasNullCreatedAtValues: undefined,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['updatedAt'],
  },
  {
    name: 'LegalDocuments',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'Members',
    hasNullCreatedAtValues: true,
    hasNullUpdatedAtValues: true,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'Notifications',
    hasNullCreatedAtValues: true,
    hasNullUpdatedAtValues: true,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'OAuthAuthorizationCodes',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'Orders',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
    dependantViews: [{ name: 'CollectiveOrderStats', isMaterialized: true }],
  },
  {
    name: 'PaymentMethods',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: true,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'PersonalTokens',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'RequiredLegalDocuments',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'Subscriptions',
    hasNullCreatedAtValues: true,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'SuspendedAssets',
    hasNullCreatedAtValues: undefined,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['updatedAt'],
  },
  {
    name: 'Tiers',
    hasNullCreatedAtValues: true,
    hasNullUpdatedAtValues: true,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  // Enforcing the non-null constraints would be too expensive, as we'd need to recreate all the dependant views
  // {
  //   name: 'Transactions',
  //   hasNullCreatedAtValues: false,
  //   hasNullUpdatedAtValues: false,
  //   missingConstraints: ['createdAt'],
  //   dependantViews: [
  //     { name: 'CurrentCollectiveBalance', isMaterialized: false },
  //     { name: 'CollectiveBalanceCheckpoint', isMaterialized: true },
  //     { name: 'TransactionBalances', isMaterialized: true },
  //   ],
  // },
  {
    name: 'Updates',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'Users',
    hasNullCreatedAtValues: false, // Migrated manually
    hasNullUpdatedAtValues: false, // Migrated manually
    missingConstraints: ['createdAt', 'updatedAt'],
  },
  {
    name: 'UserTokens',
    hasNullCreatedAtValues: false,
    hasNullUpdatedAtValues: false,
    missingConstraints: ['createdAt', 'updatedAt'],
  },
];

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    const defaultDate = '2016-01-01 00:00:00.000Z';
    const fixedColumnParams = { type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW };

    // ---- Users ----
    console.time('Seed Users');
    await queryInterface.sequelize.query(`
      UPDATE "Users" u
      SET
        "createdAt" = COALESCE(u."createdAt", c."createdAt", u."confirmedAt", u."updatedAt", c."updatedAt", u."lastLoginAt", u."deletedAt", c."deletedAt", '${defaultDate}'),
        "updatedAt" = COALESCE(u."updatedAt", u."createdAt", c."updatedAt", c."createdAt", u."confirmedAt", u."lastLoginAt", u."deletedAt", c."deletedAt", '${defaultDate}')
      FROM "Collectives" c
      WHERE (u."createdAt" IS NULL OR u."updatedAt" IS NULL)
      AND c.id = u."CollectiveId"
    `);
    console.timeEnd('Seed Users');

    // ---- Collectives ----
    console.time('Seed Collectives');
    await queryInterface.sequelize.query(`
      UPDATE "Collectives"
      SET
        "createdAt" = COALESCE(c."createdAt", u."createdAt", u."confirmedAt", u."updatedAt", c."updatedAt", u."lastLoginAt", u."deletedAt", c."deletedAt", '${defaultDate}'),
        "updatedAt" = COALESCE(c."updatedAt", c."createdAt", u."updatedAt", u."createdAt", u."confirmedAt", u."lastLoginAt", u."deletedAt", c."deletedAt", '${defaultDate}')
      FROM "Collectives" c
      LEFT JOIN "Users" u ON u."CollectiveId" = c.id
      WHERE (c."createdAt" IS NULL OR c."updatedAt" IS NULL)
      AND "Collectives".id = c.id
    `);
    console.timeEnd('Seed Collectives');

    // ---- Activities ----
    // This one is expected to be slow
    console.time('Seed Activities');
    await queryInterface.sequelize.query(`
      UPDATE "Activities"
      SET "createdAt" = COALESCE(c."createdAt", '${defaultDate}')
      FROM "Collectives" c
      WHERE "Activities"."createdAt" IS NULL
      AND "Activities"."CollectiveId" = c.id
    `);
    console.timeEnd('Seed Activities');

    // ---- Generic tables ----
    // All these tables are migrated the same way and don't need complex JOINs

    for (const table of TABLES_TO_MIGRATE) {
      // Seed values
      if (table.hasNullCreatedAtValues || table.hasNullUpdatedAtValues) {
        console.time(`Seed timestamps for ${table.name}`);
        await queryInterface.sequelize.query(`
          UPDATE "${table.name}"
          SET
            ${table.hasNullUpdatedAtValues ? `"updatedAt" = COALESCE("updatedAt", "createdAt", '${defaultDate}')` : ''}
            ${table.hasNullCreatedAtValues && table.hasNullUpdatedAtValues ? ',' : ''}
            ${table.hasNullCreatedAtValues ? `"createdAt" = COALESCE("createdAt", ${table.hasNullUpdatedAtValues !== undefined ? '"updatedAt",' : ''} '${defaultDate}')` : ''}
          WHERE
            ${table.hasNullCreatedAtValues ? `"createdAt" IS NULL` : ''}
            ${table.hasNullCreatedAtValues && table.hasNullUpdatedAtValues ? 'OR' : ''}
            ${table.hasNullUpdatedAtValues ? `"updatedAt" IS NULL` : ''}
        `);
        console.timeEnd(`Seed timestamps for ${table.name}`);
      }

      // Add constraints
      if (table.missingConstraints?.length) {
        console.time(`Add constraints for ${table.name}`);

        if (!table.dependantViews?.length) {
          // Simple case: add the constraints directly
          await Promise.all(
            table.missingConstraints.map(column =>
              queryInterface.changeColumn(table.name, column, { ...fixedColumnParams, allowNull: false }),
            ),
          );
        } else {
          // Complex case: to add the constraint, we must drop the dependant views, add the constraint, then recreate the views
          const addConstraintsQueries = table.missingConstraints.flatMap(column => [
            `ALTER TABLE "${table.name}" ALTER COLUMN "${column}" SET DEFAULT NOW();`,
            `ALTER TABLE "${table.name}" ALTER COLUMN "${column}" SET NOT NULL;`,
          ]);

          const updateQuery = getRecreateViewsQuery(table.dependantViews, addConstraintsQueries.join(' '));
          await queryInterface.sequelize.query(updateQuery);
        }

        console.timeEnd(`Add constraints for ${table.name}`);
      }
    }
  },

  async down(queryInterface, Sequelize) {
    const previousColumnParams = { type: Sequelize.DATE, allowNull: true, defaultValue: Sequelize.NOW };

    for (const table of TABLES_TO_MIGRATE) {
      if (table.missingConstraints?.length) {
        console.time(`Remove constraints for ${table.name}`);

        if (!table.dependantViews?.length) {
          // Simple case: add the constraints directly
          await Promise.all(
            table.missingConstraints.map(column =>
              queryInterface.changeColumn(table.name, column, { ...previousColumnParams, allowNull: false }),
            ),
          );
        } else {
          // Complex case: to remove the constraint, we must drop the dependant views, remove the constraint, then recreate the views
          const removeConstraintQuery = table.missingConstraints
            .map(column => `ALTER TABLE "${table.name}" ALTER COLUMN "${column}" DROP NOT NULL;`)
            .join(' ');

          const updateQuery = getRecreateViewsQuery(table.dependantViews, removeConstraintQuery);
          await queryInterface.sequelize.query(updateQuery, { logging: console.log });
        }

        console.timeEnd(`Remove constraints for ${table.name}`);
      }
    }
  },
};
