/**
 * Generates TypeScript types for all database views and materialized views
 * using Kysely's introspection API.
 *
 * @see https://www.kysely.dev/docs/recipes/introspecting-relation-metadata
 *
 * Run: npm run script scripts/dev/generate-kysely-view-types.ts
 * Output: server/types/kysely-views.ts
 */

// Load env first so config and DB are available
import '../../server/env';

import * as fs from 'fs';
import * as path from 'path';

import type { TableMetadata } from 'kysely';

import { getKysely } from '../../server/lib/kysely';
import sequelize, { QueryTypes } from '../../server/lib/sequelize';

/** PostgreSQL type names to TypeScript type string (for generated .ts file). */
const PG_TYPE_TO_TS: Record<string, string> = {
  // integers
  int2: 'number',
  int4: 'number',
  int8: 'number',
  serial: 'number',
  bigserial: 'number',
  smallint: 'number',
  integer: 'number',
  bigint: 'number',
  // float
  float4: 'number',
  float8: 'number',
  real: 'number',
  double: 'number',
  numeric: 'number',
  decimal: 'number',
  // string
  varchar: 'string',
  char: 'string',
  text: 'string',
  name: 'string',
  bpchar: 'string',
  // boolean
  bool: 'boolean',
  boolean: 'boolean',
  // date/time
  date: 'string',
  timestamp: 'string',
  timestamptz: 'string',
  time: 'string',
  timetz: 'string',
  interval: 'string',
  // json / jsonb – object or array of objects
  json: 'Record<string, unknown> | unknown[]',
  jsonb: 'Record<string, unknown> | unknown[]',
  jsonpath: 'string',
  // uuid / network
  uuid: 'string',
  inet: 'string',
  cidr: 'string',
  macaddr: 'string',
  // money
  money: 'number',
  // arrays – numeric and int arrays get proper element types
  _int2: 'number[]',
  _int4: 'number[]',
  _int8: 'number[]',
  _float4: 'number[]',
  _float8: 'number[]',
  _numeric: 'number[]',
  _decimal: 'number[]',
  _text: 'string[]',
  _varchar: 'string[]',
  _bool: 'boolean[]',
  _uuid: 'string[]',
  _timestamptz: 'string[]',
  _timestamp: 'string[]',
  _date: 'string[]',
  _jsonb: 'Record<string, unknown>[]',
  _json: 'Record<string, unknown>[]',
  // other
  bytea: 'Buffer',
  oid: 'number',
  xid: 'number',
  cid: 'number',
  tid: 'unknown',
  regproc: 'string',
  point: 'unknown',
  box: 'unknown',
  circle: 'unknown',
  line: 'unknown',
  lseg: 'unknown',
  path: 'unknown',
  polygon: 'unknown',
};

function pgTypeToTs(pgType: string): string {
  const normalized = pgType.toLowerCase();
  if (PG_TYPE_TO_TS[normalized]) {
    return PG_TYPE_TO_TS[normalized];
  }
  // array type not in map: infer element type from name (e.g. _foo -> unknown[], or keep unknown[])
  if (normalized.startsWith('_')) {
    return 'unknown[]';
  }
  // Unmapped types (e.g. custom enums, domain types) – treat as string
  return 'string';
}

/** Escape and quote table/view name for use as a TypeScript key (e.g. reserved words). */
function tsKey(name: string): string {
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name) && name !== 'default') {
    return name;
  }
  return JSON.stringify(name);
}

/** Generate a single row type (interface) for a view. */
function generateViewRowType(view: TableMetadata, indent: string): { interfaceName: string; lines: string[] } {
  const interfaceName = `${view.name}Row`;
  const lines: string[] = [`export interface ${interfaceName} {`];
  for (const col of view.columns) {
    const tsType = pgTypeToTs(col.dataType);
    const optional = col.isNullable ? '?' : '';
    lines.push(`${indent}${col.name}${optional}: ${tsType};`);
  }
  lines.push('}');
  return { interfaceName, lines };
}

/** Generate the ViewsDatabase type and the file content. */
function generateTypesFile(views: TableMetadata[]): string {
  const indent = '  ';
  const sections: string[] = [
    '/**',
    ' * Kysely row types for database views and materialized views.',
    ' * Auto-generated by scripts/dev/generate-kysely-view-types.ts',
    ' * Do not edit by hand.',
    ' */',
    '',
  ];

  const viewEntries: string[] = [];
  for (const view of views) {
    const { interfaceName, lines } = generateViewRowType(view, indent);
    sections.push(...lines);
    sections.push('');
    viewEntries.push(`${indent}${tsKey(view.name)}: ${interfaceName};`);
  }

  sections.push(
    '/**',
    ' * Database interface containing only views and materialized views.',
    " * Use with Kysely when querying views, e.g. getKysely().selectFrom('ViewName').selectAll()",
    ' */',
    'export type ViewsDatabase = {',
    ...viewEntries,
    '};',
    '',
  );

  return sections.join('\n');
}

/** Fetch materialized views from pg_catalog (Kysely introspector only returns tables + regular views). */
async function fetchMaterializedViews(): Promise<TableMetadata[]> {
  const rows = await sequelize.query<{
    column: string;
    not_null: boolean;
    has_default: boolean;
    table: string;
    schema: string;
    type: string;
    type_schema: string;
    column_description: string | null;
  }>(
    `
    SELECT
      a.attname AS column,
      a.attnotnull AS not_null,
      a.atthasdef AS has_default,
      c.relname AS table,
      ns.nspname AS schema,
      typ.typname AS type,
      dtns.nspname AS type_schema,
      col_description(a.attrelid, a.attnum) AS column_description
    FROM pg_catalog.pg_attribute AS a
    INNER JOIN pg_catalog.pg_class AS c ON a.attrelid = c.oid
    INNER JOIN pg_catalog.pg_namespace AS ns ON c.relnamespace = ns.oid
    INNER JOIN pg_catalog.pg_type AS typ ON a.atttypid = typ.oid
    INNER JOIN pg_catalog.pg_namespace AS dtns ON typ.typnamespace = dtns.oid
    WHERE c.relkind = 'm'
      AND ns.nspname !~ '^pg_'
      AND ns.nspname != 'information_schema'
      AND a.attnum >= 0
      AND a.attisdropped != true
    ORDER BY ns.nspname, c.relname, a.attnum
  `,
    {
      type: QueryTypes.SELECT,
      raw: true,
    },
  );

  const byTable = new Map<string, TableMetadata>();
  for (const it of rows) {
    const key = `${it.schema ?? 'public'}.${it.table}`;
    let meta = byTable.get(key);
    if (!meta) {
      meta = {
        name: it.table,
        isView: true,
        schema: it.schema,
        columns: [],
      };
      byTable.set(key, meta);
    }
    meta.columns.push({
      name: it.column,
      dataType: it.type,
      dataTypeSchema: it.type_schema,
      isNullable: !it.not_null,
      isAutoIncrementing: false,
      hasDefaultValue: it.has_default,
      comment: it.column_description ?? undefined,
    });
  }
  return Array.from(byTable.values());
}

async function main(): Promise<void> {
  const db = getKysely();
  const allTables = await db.introspection.getTables();
  const regularViews = allTables.filter(t => t.isView);
  const materializedViews = await fetchMaterializedViews();

  const views = [...regularViews];
  const seen = new Set(regularViews.map(v => `${v.schema ?? 'public'}.${v.name}`));
  for (const mv of materializedViews) {
    const key = `${mv.schema ?? 'public'}.${mv.name}`;
    if (!seen.has(key)) {
      seen.add(key);
      views.push(mv);
    }
  }

  views.sort((a, b) => {
    const nameA = a.name.toLowerCase();
    const nameB = b.name.toLowerCase();
    return nameA.localeCompare(nameB);
  });

  const content = generateTypesFile(views);
  const outPath = path.join(__dirname, '../../server/types/kysely-views.ts');
  fs.writeFileSync(outPath, content, 'utf8');
  console.log(`Wrote ${views.length} view(s) to ${outPath}`);
}

if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch(err => {
      console.error(err);
      process.exit(1);
    });
}
