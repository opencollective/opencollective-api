import { differenceBy, flatten, get, isEqual, isNil, isPlainObject, isUndefined, merge, pick } from 'lodash';
import { Model } from 'sequelize';

/** A diff as [newEntries, removedEntries, updatedEntries] */
type DBEntriesDiff<BaseModel extends Model, CreateOrUpdateAttributes = Record<string, unknown>> = [
  CreateOrUpdateAttributes[],
  BaseModel[],
  CreateOrUpdateAttributes[],
];

/**
 * @deprecated Use `richDiffDBEntries` instead
 *
 * Diff two lists of DB objects and returns which ones where created, removed and updated.
 * Useful for places where we update an attribute by providing a list.
 *
 * @param {Array} oldEntries: Existing entries
 * @param {Array} newEntries: New entries to update with
 * @param {Array} diffedFields: The fields used to compare objects for ``
 * @returns [newEntries, removedEntries, updatedEntries]
 */
export function diffDBEntries<T extends Model>(
  oldEntries: T[],
  newEntriesData: Record<string, unknown>[],
  diffedFields: string[],
  idField = 'id',
): DBEntriesDiff<T> {
  const toRemove = differenceBy(oldEntries, newEntriesData, idField);
  const toCreate = [];
  const toUpdate = [];
  newEntriesData.forEach(entry => {
    if (!entry[idField]) {
      toCreate.push(entry);
    } else {
      const existingEntry = oldEntries.find(oldEntry => oldEntry.get(idField) === entry[idField]);
      // We throw here to protect against security issues where users would try
      // to update an entry that doesn't exist in `oldEntries`. Example: trying
      // to update an existing member that's part of another collective.
      // The error can also be throwed if users edit an entity that has been removed in
      // another tab or by someone else.
      if (!existingEntry) {
        throw new Error(
          "One of the entity you're trying to update doesn't exist or has changes. Please refresh the page.",
        );
      } else if (!diffedFields.every(field => isEqual(existingEntry[field], entry[field]))) {
        toUpdate.push(entry);
      }
    }
  });

  return [toCreate, toRemove, toUpdate];
}

type RichDBEntriesDiff<BaseModel extends Model, CreateOrUpdateAttributes = Record<string, unknown>> = {
  toCreate: Array<CreateOrUpdateAttributes>;
  toRemove: Array<BaseModel>;
  toUpdate: Array<{ model: BaseModel; newValues: CreateOrUpdateAttributes }>;
};

/**
 * Diff two lists of DB objects and returns which ones where created, removed and updated.
 * Useful for places where we update an attribute by providing a list.
 *
 * @param {Array} oldEntries: Existing entries
 * @param {Array} newEntries: New entries to update with
 * @param {Array} diffedFields: The fields used to compare objects for ``
 * @returns [newEntries, removedEntries, updatedEntries]
 */
export function richDiffDBEntries<BaseModel extends Model, CreateOrUpdateAttributes = Record<string, unknown>>(
  oldEntries: BaseModel[],
  newEntriesData: CreateOrUpdateAttributes[],
  diffedFields: readonly (keyof CreateOrUpdateAttributes)[],
  { idField = 'id' } = {},
): RichDBEntriesDiff<BaseModel, CreateOrUpdateAttributes> {
  const toRemove = differenceBy(oldEntries, newEntriesData, idField);
  const toCreate: CreateOrUpdateAttributes[] = [];
  const toUpdate: Array<{ model: BaseModel; newValues: CreateOrUpdateAttributes }> = [];
  newEntriesData.forEach(entry => {
    if (isNil(entry[idField])) {
      toCreate.push(entry);
    } else {
      const existingEntry = oldEntries.find(oldEntry => oldEntry.get(idField) === entry[idField]);
      // We throw here to protect against security issues where users would try
      // to update an entry that doesn't exist in `oldEntries`. Example: trying
      // to update an existing member that's part of another collective.
      // The error can also be throwed if users edit an entity that has been removed in
      // another tab or by someone else.
      if (!existingEntry) {
        throw new Error(
          "One of the entity you're trying to update doesn't exist or has changes. Please refresh the page.",
        );
      } else if (
        !diffedFields.every(field => isUndefined(entry[field]) || isEqual(existingEntry[field as string], entry[field]))
      ) {
        toUpdate.push({ model: existingEntry, newValues: entry });
      }
    }
  });

  return { toCreate, toRemove, toUpdate };
}

/**
 * Returns a simulated list of DB entries based on existing ones modified after the diff
 * generated by `diffDBEntries(oldEntries, newEntriesData)`.
 */
export function simulateDBEntriesDiff<T extends Model>(
  oldEntries: T[],
  diff: DBEntriesDiff<T>,
  idField = 'id',
): Record<string, unknown>[] {
  const [newEntries, removedEntries, updatedEntries] = diff;
  return [
    ...oldEntries
      .filter(entry => !removedEntries.some(removedEntry => removedEntry === entry))
      .map(entry => {
        const updatedEntry = updatedEntries.find(updatedEntry => updatedEntry[idField] === entry.get(idField));
        if (updatedEntry) {
          return merge(entry['dataValues'], updatedEntry);
        } else {
          return <Record<string, unknown>>entry;
        }
      }),
    ...newEntries,
  ];
}

/**
 * Returns true if the error is a Sequelize UniqueConstraintError.
 *
 * @param {Error} error: the error
 * @param {string | string[]} fields: the field(s) on which the unique constraint was violated. If non provided, will return true if any unique constraint was violated.
 * @returns
 */
export const isUniqueConstraintError = (error, fields = undefined) => {
  if (!error || error.name !== 'SequelizeUniqueConstraintError') {
    return false;
  } else if (!fields) {
    return true;
  } else {
    return error.errors.every(e => fields.includes(e.path));
  }
};

const keysDeep = (obj: object, prefix?: string) =>
  flatten(
    Object.keys(obj).map(key => {
      const path = [prefix, key].filter(x => x !== undefined).join('.');
      if (isPlainObject(get(obj, key))) {
        return flatten(keysDeep(obj[key], path));
      } else {
        return path;
      }
    }),
  );

export const getDiffBetweenInstances = <T extends Model>(newData: object | T, previousData: object | T) => {
  newData = newData instanceof Model ? newData.toJSON() : newData;
  previousData = previousData instanceof Model ? previousData.toJSON() : previousData;

  const newKeys = keysDeep(newData);
  const updatedKeys = newKeys.filter(k => get(newData, k) !== get(previousData, k));
  return {
    newData: pick(newData, updatedKeys),
    previousData: pick(previousData, updatedKeys),
  };
};
