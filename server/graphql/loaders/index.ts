import DataLoader from 'dataloader';
import { createContext } from 'dataloader-sequelize';
import { get, groupBy } from 'lodash';
import moment from 'moment';
import { OrderItem } from 'sequelize';

import { CollectiveType } from '../../constants/collectives';
import { Service } from '../../constants/connected-account';
import { SupportedCurrency } from '../../constants/currencies';
import orderStatus from '../../constants/order-status';
import { TransactionTypes } from '../../constants/transactions';
import {
  getBalances,
  getSumCollectivesAmountReceived,
  getSumCollectivesAmountSpent,
  getYearlyBudgets,
  sumCollectivesTransactions,
} from '../../lib/budget';
import { getFxRate } from '../../lib/currency';
import { ifStr } from '../../lib/utils';
import {
  Collective,
  ConnectedAccount,
  Expense,
  Member,
  Models,
  Op,
  Order,
  PaymentMethod,
  sequelize,
  SocialLink,
  Subscription,
  Transaction,
  TransactionsImportRow,
  UploadedFile,
} from '../../models';
import { ExpenseStatus } from '../../models/Expense';

import { generateTotalAccountHostAgreementsLoader } from './agreements';
import collectiveLoaders from './collective';
import commentsLoader from './comments';
import contributorsLoaders from './contributors';
import conversationLoaders from './conversation';
import { generateConvertToCurrencyLoader, generateFxRateLoader } from './currency-exchange-rate';
import * as expenseLoaders from './expenses';
import { buildLoaderForAssociation, sortResults, sortResultsArray, sortResultsSimple } from './helpers';
import locationLoaders from './location';
import {
  generateAdminUsersEmailsForCollectiveLoader,
  generateCountAdminMembersOfCollective,
  generateMemberIsActiveLoader,
  generateRemoteUserIsAdminOfHostedAccountLoader,
  generateRemoteUserIsIndirectFinancialContributor,
} from './members';
import * as orderLoaders from './order';
import { generateCollectivePayoutMethodsLoader, generateCollectivePaypalPayoutMethodsLoader } from './payout-method';
import { generateSearchLoaders } from './search';
import * as transactionLoaders from './transactions';
import {
  generateOffPlatformTransactionsStatsLoader,
  generateTransactionsImportStatsLoader,
} from './transactions-import';
import updatesLoader from './updates';
import { generateUserByCollectiveIdLoader, generateUserHasTwoFactorAuthEnabled } from './user';
import { generateCollectiveVirtualCardLoader, generateHostCollectiveVirtualCardLoader } from './virtual-card';

interface ContextualLoader<T> {
  byId: DataLoader<number | string, T>;
  [key: string]: DataLoader<unknown, T>;
}

type ContextualLoaders = {
  [k in keyof Models]: ContextualLoader<InstanceType<Models[k]>>;
} & {
  autogenerated: { reset: () => void };
};

export type Loaders = ReturnType<typeof generateLoaders>;

export const generateLoaders = req => {
  const context: {
    loaders: ContextualLoaders;
  } = createContext(sequelize);

  const cachedLoaders = {};

  const loaders = {
    ...context.loaders,
    CurrencyExchangeRate: {
      ...context.loaders.CurrencyExchangeRate,
      convert: generateConvertToCurrencyLoader(),
      fxRate: generateFxRateLoader(),
    },
    Comment: {
      ...context.loaders.Comment,
      countByExpenseAndType: commentsLoader.countByExpenseAndType(),
      countByHostApplication: commentsLoader.countByHostApplication(),
      // Comment Reactions
      reactionsByCommentId: commentsLoader.reactionsByCommentId(),
      remoteUserReactionsByCommentId: commentsLoader.remoteUserReactionsByCommentId(req),
    },
    Update: {
      ...context.loaders.Update,
      // Update Reactions
      reactionsByUpdateId: updatesLoader.reactionsByUpdateId(),
      remoteUserReactionsByUpdateId: updatesLoader.remoteUserReactionsByUpdateId(req),
    },
    UploadedFile: {
      ...context.loaders.UploadedFile,
      byUrl: new DataLoader(async (urls: string[]) => {
        const files = await UploadedFile.findAll({ where: { url: urls } });
        return sortResultsSimple(urls, files, file => file.getDataValue('url'));
      }),
    },
    Conversation: {
      ...context.loaders.Conversation,
      followers: conversationLoaders.followers(),
      commentsCount: conversationLoaders.commentsCount(),
    },
    Expense: {
      ...context.loaders.Expense,
      activities: expenseLoaders.generateExpenseActivitiesLoader(),
      attachedFiles: expenseLoaders.attachedFiles(),
      items: expenseLoaders.generateExpenseItemsLoader(),
      taxFormRequiredBeforePayment: expenseLoaders.taxFormRequiredBeforePayment(),
      expenseToHostTransactionFxRateLoader: expenseLoaders.generateExpenseToHostTransactionFxRateLoader(),
      securityChecks: expenseLoaders.generateExpensesSecurityCheckLoader(req),
    },
    Agreement: {
      ...context.loaders.Agreement,
      totalAccountHostAgreements: generateTotalAccountHostAgreementsLoader(),
    },
    PayoutMethod: {
      ...context.loaders.PayoutMethod,
      paypalByCollectiveId: generateCollectivePaypalPayoutMethodsLoader(),
      byCollectiveId: generateCollectivePayoutMethodsLoader(),
      allByCollectiveId: generateCollectivePayoutMethodsLoader({ excludeArchived: false }),
    },
    VirtualCard: {
      ...context.loaders.VirtualCard,
      byCollectiveId: generateCollectiveVirtualCardLoader(),
      byHostCollectiveId: generateHostCollectiveVirtualCardLoader(),
    },
    User: {
      ...context.loaders.User,
      byCollectiveId: generateUserByCollectiveIdLoader(),
      hasTwoFactorAuthEnabled: generateUserHasTwoFactorAuthEnabled(),
    },
    Location: {
      ...context.loaders.Location,
      byCollectiveId: locationLoaders.byCollectiveId(),
    },
    Collective: {
      ...context.loaders.Collective,
      byUserId: collectiveLoaders.byUserId(),
      mainProfileFromIncognito: collectiveLoaders.mainProfileFromIncognito(),
      hostByCollectiveId: new DataLoader<number, Collective>(ids =>
        Collective.findAll({
          attributes: ['id'],
          where: { id: { [Op.in]: ids }, isActive: true },
          include: [{ model: Collective, as: 'host' }],
        }).then(results => {
          const resultsById = {};
          for (const result of results) {
            resultsById[result.id] = result.host;
          }
          return ids.map(id => resultsById[id] || null);
        }),
      ),
      hostByStripeAccount: new DataLoader<string, Collective>(ids =>
        ConnectedAccount.findAll({
          attributes: ['id', 'username'],
          where: { username: { [Op.in]: ids }, service: Service.STRIPE },
          include: [{ model: Collective, as: 'collective', where: { isHostAccount: true } }],
        }).then(results => {
          const resultsById = {};
          for (const result of results) {
            resultsById[result.username] = result.collective;
          }
          return ids.map(id => resultsById[id] || null);
        }),
      ),

      hostedCollectivesCount: new DataLoader<number, number>(async collectiveIds => {
        const results = await Collective.findAll({
          raw: true,
          attributes: ['HostCollectiveId', [sequelize.fn('COUNT', sequelize.col('id')), 'count']],
          group: ['HostCollectiveId'],
          where: {
            HostCollectiveId: collectiveIds,
            type: [CollectiveType.COLLECTIVE, CollectiveType.FUND],
            isActive: true,
            approvedAt: { [Op.not]: null },
          },
        });

        return sortResultsSimple(collectiveIds, results, r => r.HostCollectiveId).map(result => result?.['count'] ?? 0);
      }),

      parent: buildLoaderForAssociation<Collective, Collective>(Collective, 'parent', {
        loader: parentIds => context.loaders.Collective.byId.loadMany(parentIds) as Promise<Collective[]>,
      }) as DataLoader<Collective, Collective>,

      host: buildLoaderForAssociation<Collective, Collective>(Collective, 'host', {
        filter: collective => Boolean(collective.approvedAt),
        loader: ids => context.loaders.Collective.byId.loadMany(ids) as Promise<Collective[]>,
      }) as DataLoader<Collective, Collective>,

      currentCollectiveBalance: new DataLoader<
        number,
        {
          netAmountInHostCurrnecy: number;
          disputednetAmountInHostCurrency: number;
          hostCurrency: string;
          CollectiveId: number;
        }
      >(collectiveIds =>
        sequelize
          .query(
            `SELECT ccb.*
         FROM "CurrentCollectiveBalance" ccb
         INNER JOIN "Collectives" c ON ccb."CollectiveId" = c."id"
         AND COALESCE(TRIM('"' FROM (c."settings"->'budget'->'version')::text), 'v2') = 'v2'
         WHERE ccb."CollectiveId" IN (:collectiveIds)`,
            {
              replacements: { collectiveIds },
              type: sequelize.QueryTypes.SELECT,
              raw: true,
            },
          )
          .then(results => sortResults(collectiveIds, Object.values(results), 'CollectiveId')),
      ),

      currentCollectiveTransactionStats: new DataLoader<
        number,
        {
          CollectiveId: number;
          totalAmountReceivedInHostCurrency: number;
          totalNetAmountReceivedInHostCurrency: number;
          totalAmountSpentInHostCurrency: number;
          totalNetAmountSpentInHostCurrency: number;
          hostCurrency: string;
        }
      >(collectiveIds =>
        sequelize
          .query(`SELECT * FROM "CurrentCollectiveTransactionStats" WHERE "CollectiveId" IN (:collectiveIds)`, {
            replacements: { collectiveIds },
            type: sequelize.QueryTypes.SELECT,
            raw: true,
          })
          .then(results => sortResults(collectiveIds, Object.values(results), 'CollectiveId')),
      ),

      // Collective - Balance
      balance: {
        buildLoader({ endDate = null, includeChildren = false, withBlockedFunds = false } = {}) {
          const key = `collective-balance-${endDate}-${includeChildren}-${withBlockedFunds}`;
          if (!cachedLoaders[key]) {
            cachedLoaders[key] = new DataLoader<number, { CollectiveId: number; value: number; currency: string }>(
              async ids => {
                const results = await getBalances(ids, {
                  endDate,
                  includeChildren,
                  withBlockedFunds,
                  loaders: loaders,
                });
                return sortResults(ids, Object.values(results), 'CollectiveId') as {
                  CollectiveId: number;
                  value: number;
                  currency: string;
                }[];
              },
            );
          }
          return cachedLoaders[key] as DataLoader<number, { CollectiveId: number; value: number; currency: string }>;
        },
      },

      // Collective - Amount Received
      amountReceived: {
        buildLoader({
          net = false,
          kind = undefined,
          startDate = null,
          endDate = null,
          includeChildren = false,
        }: { net?: boolean; kind?: string; startDate?: Date; endDate?: Date; includeChildren?: boolean } = {}) {
          const key = `amountReceived-${net}-${kind}-${startDate}-${endDate}-${includeChildren}`;
          if (!cachedLoaders[key]) {
            cachedLoaders[key] = new DataLoader<number, { CollectiveId: number; value: number; currency: string }>(
              ids =>
                getSumCollectivesAmountReceived(ids, {
                  net,
                  kind,
                  startDate,
                  endDate,
                  includeChildren,
                  loaders: loaders,
                }).then(
                  results =>
                    sortResults(ids, Object.values(results), 'CollectiveId') as {
                      CollectiveId: number;
                      value: number;
                      currency: string;
                    }[],
                ),
            );
          }
          return cachedLoaders[key] as DataLoader<number, { CollectiveId: number; value: number; currency: string }>;
        },
      },

      // // Collective - Amount Received Time Series
      amountReceivedTimeSeries: {
        buildLoader({
          net,
          kind,
          startDate,
          endDate,
          includeChildren,
          timeUnit,
        }: {
          net?: boolean;
          kind?: string;
          startDate?: Date;
          endDate?: Date;
          includeChildren?: boolean;
          timeUnit?: string;
        } = {}) {
          const key = `amountReceivedTimeSeries-${net}-${kind}-${startDate}-${endDate}-${includeChildren}-${timeUnit}`;
          if (!cachedLoaders[key]) {
            cachedLoaders[key] = new DataLoader<number, { CollectiveId: number; value: number; currency: string }>(
              ids =>
                getSumCollectivesAmountReceived(ids, {
                  net,
                  kind,
                  startDate,
                  endDate,
                  includeChildren,
                  groupByAttributes: [
                    [sequelize.fn('DATE_TRUNC', timeUnit, sequelize.col('Transaction.createdAt')), 'date'],
                  ],
                }).then(
                  results =>
                    sortResults(ids, Object.values(results), 'CollectiveId') as {
                      CollectiveId: number;
                      value: number;
                      currency: string;
                    }[],
                ),
            );
          }
          return cachedLoaders[key] as DataLoader<number, { CollectiveId: number; value: number; currency: string }>;
        },
      },

      // // Collective -  Amount Spent
      amountSpent: {
        buildLoader({
          net,
          kind,
          startDate,
          endDate,
          includeChildren,
          includeGiftCards,
        }: {
          net?: boolean;
          kind?: TransactionTypes;
          startDate?: Date;
          endDate?: Date;
          includeChildren?: boolean;
          includeGiftCards?: boolean;
        } = {}) {
          const key = `amount-spent-${net}-${kind}-${startDate}-${endDate}-${includeChildren}-${includeGiftCards}`;
          if (!cachedLoaders[key]) {
            cachedLoaders[key] = new DataLoader<number, { CollectiveId: number; value: number; currency: string }>(
              ids =>
                getSumCollectivesAmountSpent(ids, {
                  net,
                  kind,
                  startDate,
                  endDate,
                  includeChildren,
                  includeGiftCards,
                  loaders: loaders,
                }).then(
                  results =>
                    sortResults(ids, Object.values(results), 'CollectiveId') as {
                      CollectiveId: number;
                      value: number;
                      currency: string;
                    }[],
                ),
            );
          }
          return cachedLoaders[key] as DataLoader<number, { CollectiveId: number; value: number; currency: string }>;
        },
      },

      // // Collective -  Count of contributions and contributors
      contributionsAndContributorsCount: {
        buildLoader({
          startDate,
          endDate,
          includeChildren,
        }: { startDate?: Date; endDate?: Date; includeChildren?: boolean } = {}) {
          const key = `contributionsAndContributorsCount-${startDate}-${endDate}-${includeChildren}`;
          if (!cachedLoaders[key]) {
            cachedLoaders[key] = new DataLoader<
              number,
              {
                CollectiveId: number;
                value: number;
                currency: string;
                count: number;
                countDistinctFromCollective: number;
              }
            >(ids =>
              sumCollectivesTransactions(ids, {
                column: 'amountInHostCurrency',
                startDate,
                endDate,
                includeChildren,
                kind: ['CONTRIBUTION', 'ADDED_FUNDS'],
                transactionType: 'CREDIT',
                extraAttributes: [
                  [sequelize.fn('COUNT', sequelize.col('Transaction.id')), 'count'],
                  [
                    sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('Transaction.FromCollectiveId'))),
                    'countDistinctFromCollective',
                  ],
                ],
              }).then(
                results =>
                  sortResults(ids, Object.values(results), 'CollectiveId') as {
                    CollectiveId: number;
                    value: number;
                    currency: string;
                    count: number;
                    countDistinctFromCollective: number;
                  }[],
              ),
            );
          }
          return cachedLoaders[key];
        },
      },

      // Collective - ConnectedAccounts
      connectedAccounts: new DataLoader<number, ConnectedAccount[]>(async ids => {
        const results = await ConnectedAccount.findAll({
          where: { CollectiveId: { [Op.in]: ids } },
        });
        return sortResults(ids, results, 'CollectiveId', []) as ConnectedAccount[][];
      }),

      canSeePrivateInfo: collectiveLoaders.canSeePrivateInfo(req),

      childrenIds: new DataLoader<number, number[]>(ids =>
        Collective.findAll({
          mapToModel: false,
          raw: true,
          where: { ParentCollectiveId: { [Op.in]: ids } },
          attributes: ['ParentCollectiveId', 'id'],
        }).then(results => {
          const groupedResults = groupBy(results, 'ParentCollectiveId');
          return ids.map(id => groupedResults[id]?.map(result => result.id) || []);
        }),
      ),

      yearlyBudget: new DataLoader<number, { CollectiveId: number; value: number; currency: string }>(ids =>
        getYearlyBudgets(ids).then(
          (results: Record<number, { CollectiveId: number; value: number; currency: string }>) =>
            sortResults(ids, Object.values(results), 'CollectiveId') as {
              CollectiveId: number;
              value: number;
              currency: string;
            }[],
        ),
      ),

      // // Collective - Stats
      stats: {
        backers: new DataLoader<number, Partial<Record<CollectiveType, number>> & Record<'all' | 'id', number>>(
          async ids => {
            const rows = (await Member.findAll({
              attributes: [
                'CollectiveId',
                'memberCollective.type',
                [
                  sequelize.fn(
                    'COALESCE',
                    sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('Member.MemberCollectiveId'))),
                    0,
                  ),
                  'count',
                ],
              ],
              where: {
                CollectiveId: { [Op.in]: ids },
                role: 'BACKER',
              },
              include: {
                model: Collective,
                as: 'memberCollective',
                attributes: ['type'],
              },
              group: ['CollectiveId', 'memberCollective.type'],
              raw: true,
            })) as unknown as { CollectiveId: number; type: string; count: number }[];

            const rowsByCollective = groupBy(rows, 'CollectiveId');
            const results = ids.map(id => {
              const result = get(rowsByCollective, id, []);
              const stats: Partial<Record<CollectiveType, number>> & Record<'all' | 'id', number> = result.reduce(
                (acc, value) => {
                  acc['all'] += value.count;
                  acc[value.type] = value.count;
                  return acc;
                },
                { id, all: 0 } as any,
              );
              return {
                CollectiveId: Number(id),
                ...stats,
              };
            });

            return sortResults(ids, results, 'CollectiveId') as Array<
              Partial<Record<CollectiveType, number>> & Record<'all' | 'id', number>
            >;
          },
        ),
        expenses: new DataLoader<number, Partial<Record<ExpenseStatus, number>> & { CollectiveId: number }>(
          async ids => {
            const rows = (await Expense.findAll({
              attributes: [
                'CollectiveId',
                'status',
                [sequelize.fn('COALESCE', sequelize.fn('COUNT', sequelize.col('id')), 0), 'count'],
              ],
              where: { CollectiveId: { [Op.in]: ids } },
              group: ['CollectiveId', 'status'],
              raw: true,
            })) as unknown as { CollectiveId: number; status: ExpenseStatus; count: number }[];
            const rowsGroupedByCollective = groupBy(rows, 'CollectiveId');
            const results = Object.keys(rowsGroupedByCollective).map(CollectiveId => {
              const stats: Partial<Record<ExpenseStatus, number>> = {};
              rowsGroupedByCollective[CollectiveId].map(stat => {
                stats[stat.status] = stat.count;
              });
              return {
                CollectiveId: Number(CollectiveId),
                ...stats,
              };
            });
            return sortResults(ids, results, 'CollectiveId') as Array<
              Partial<Record<ExpenseStatus, number>> & { CollectiveId: number }
            >;
          },
        ),
        activeRecurringContributions: {
          buildLoader({
            currency,
            includeChildren = undefined,
          }: { currency?: SupportedCurrency; includeChildren?: boolean } = {}) {
            const key = `activeRecurringContributions-${currency}-${includeChildren}`;
            if (!cachedLoaders[key]) {
              const collectiveIdCol = !includeChildren
                ? 'CollectiveId'
                : sequelize.fn(
                    'COALESCE',
                    sequelize.col('collective.ParentCollectiveId'),
                    sequelize.col('collective.id'),
                  );
              cachedLoaders[key] = new DataLoader<
                number,
                { CollectiveId: number; monthly: number; monthlyCount: number; yearly: number; yearlyCount: number }
              >(async ids => {
                const rows = (await Order.findAll({
                  attributes: [
                    [collectiveIdCol, 'CollectiveId'],
                    'Order.currency',
                    'Subscription.interval',
                    [sequelize.fn('COUNT', sequelize.literal(`DISTINCT "Order"."id"`)), 'count'],
                    [
                      sequelize.fn(
                        'SUM',
                        sequelize.literal(
                          `COALESCE("Order"."totalAmount", 0) - COALESCE("Order"."platformTipAmount", 0)`,
                        ),
                      ),
                      'total',
                    ],
                  ],
                  where: {
                    status: 'ACTIVE',
                  },
                  group: ['Subscription.interval', collectiveIdCol, 'Order.currency'],
                  include: [
                    {
                      association: 'collective',
                      attributes: [],
                      required: true,
                      where: !includeChildren ? { id: ids } : { [Op.or]: [{ id: ids }, { ParentCollectiveId: ids }] },
                    },
                    {
                      model: Subscription,
                      attributes: [],
                      required: true,
                      where: {
                        isActive: true,
                      },
                    },
                  ],
                  raw: true,
                })) as unknown as {
                  CollectiveId: number;
                  currency: string;
                  interval: string;
                  count: number;
                  total: number;
                }[];
                const results = groupBy(rows, 'CollectiveId');
                return Promise.all(
                  ids.map(async collectiveId => {
                    const stats = {
                      CollectiveId: Number(collectiveId),
                      monthly: 0,
                      monthlyCount: 0,
                      yearly: 0,
                      yearlyCount: 0,
                    };
                    if (results[collectiveId]) {
                      for (const result of results[collectiveId]) {
                        const interval = result.interval === 'month' ? 'monthly' : 'yearly';
                        const fxRate = await getFxRate(result.currency as SupportedCurrency, currency);
                        stats[interval] += result.total * fxRate;
                        stats[`${interval}Count`] += result.count;
                      }
                    }
                    return stats;
                  }),
                );
              });
            }
            return cachedLoaders[key] as DataLoader<
              number,
              { CollectiveId: number; monthly: number; monthlyCount: number; yearly: number; yearlyCount: number }
            >;
          },
        },
        orders: new DataLoader<
          number,
          {
            CollectiveId: number;
            errorRate1M: number;
            errorRate3M: number;
            errorRate12M: number;
            numOrders1M: number;
            numOrders3M: number;
            numOrders12M: number;
          }
        >(async collectiveIds => {
          const stats = (await sequelize.query(
            `SELECT * FROM "CollectiveOrderStats" WHERE "CollectiveId" IN (:collectiveIds)`,
            {
              replacements: { collectiveIds },
              type: sequelize.QueryTypes.SELECT,
              raw: true,
            },
          )) as {
            CollectiveId: number;
            errorRate1M: number;
            errorRate3M: number;
            errorRate12M: number;
            numOrders1M: number;
            numOrders3M: number;
            numOrders12M: number;
          }[];

          return sortResultsSimple(collectiveIds, stats, row => row.CollectiveId);
        }),
        hostedAccountSummary: {
          buildLoader: ({ dateFrom, dateTo }: { dateFrom?: Date; dateTo?: Date } = {}) => {
            const key = `hostedAccountSummary-${dateFrom}-${dateTo}`;
            if (!cachedLoaders[key]) {
              cachedLoaders[key] = new DataLoader<
                number,
                {
                  CollectiveId: number;
                  hostCurrency: string;
                  daysSinceApproved: number;
                  expenseCount: number;
                  expenseTotal: number;
                  expenseMaxValue: number;
                  expenseDistinctPayee: number;
                  contributionCount: number;
                  contributionTotal: number;
                  contributionRefundedTotal: number;
                  hostFeeTotal: number;
                  spentTotal: number;
                  receivedTotal: number;
                }
              >(async collectiveIds => {
                const stats = (await sequelize.query(
                  `
                  SELECT
                    t."CollectiveId",
                    t."hostCurrency",
                    EXTRACT('days' FROM (NOW() - MAX(c."approvedAt"))) as "daysSinceApproved",
                    COUNT(t.id) FILTER (WHERE t.kind = 'EXPENSE' AND t.type = 'DEBIT') AS "expenseCount",
                    SUM(ABS(t."amountInHostCurrency")) FILTER (WHERE t.kind = 'EXPENSE' AND t.type = 'DEBIT') AS "expenseTotal",
                    MAX(ABS(t."amountInHostCurrency")) FILTER (WHERE t.kind = 'EXPENSE' AND t.type = 'DEBIT') AS "expenseMaxValue",
                    COUNT(DISTINCT t."FromCollectiveId") FILTER (WHERE t.kind = 'EXPENSE' AND t.type = 'DEBIT') AS "expenseDistinctPayee",
                    COUNT(t.id) FILTER (WHERE t.kind IN ('CONTRIBUTION', 'ADDED_FUNDS') AND t.type = 'CREDIT') AS "contributionCount",
                    SUM(t."amountInHostCurrency") FILTER (WHERE t.kind IN ('CONTRIBUTION', 'ADDED_FUNDS') AND t.type = 'CREDIT') AS "contributionTotal",
                    SUM(ABS(t."amountInHostCurrency")) FILTER (WHERE t.kind IN ('CONTRIBUTION', 'ADDED_FUNDS') AND t.type = 'DEBIT' AND t."isRefund" = true) AS "contributionRefundedTotal",
                    SUM(ABS(t."amountInHostCurrency")) FILTER (WHERE t.kind = 'HOST_FEE' AND t.type = 'DEBIT') AS "hostFeeTotal",
                    SUM(ABS(t."amountInHostCurrency")) FILTER (WHERE t.type = 'DEBIT' AND t.kind != 'HOST_FEE' AND t.kind != 'PAYMENT_PROCESSOR_FEE') AS "spentTotal",
                    SUM(ABS(t."amountInHostCurrency")) FILTER (WHERE t.type = 'CREDIT' AND t."kind" NOT IN ('PAYMENT_PROCESSOR_COVER')) AS "receivedTotal"
                  FROM
                    "Transactions" t
                    INNER JOIN "Collectives" c ON t."CollectiveId" = c.id
                  WHERE t."CollectiveId" IN (:collectiveIds)
                    AND t."deletedAt" IS NULL
                    ${ifStr(dateFrom, 'AND t."createdAt" > :dateFrom', 'AND t."createdAt" > c."approvedAt"')}
                    ${ifStr(dateTo, 'AND t."createdAt" <= :dateTo')}
                    AND t."HostCollectiveId" = c."HostCollectiveId"
                  GROUP BY
                    t."CollectiveId", t."hostCurrency"
                  `,
                  {
                    replacements: {
                      collectiveIds,
                      dateFrom,
                      dateTo,
                    },
                    type: sequelize.QueryTypes.SELECT,
                    raw: true,
                  },
                )) as {
                  CollectiveId: number;
                  hostCurrency: string;
                  daysSinceApproved: number;
                  expenseCount: number;
                  expenseTotal: number;
                  expenseMaxValue: number;
                  expenseDistinctPayee: number;
                  contributionCount: number;
                  contributionTotal: number;
                  contributionRefundedTotal: number;
                  hostFeeTotal: number;
                  spentTotal: number;
                  receivedTotal: number;
                }[];

                return sortResultsSimple(collectiveIds, stats, row => row.CollectiveId);
              });
            }

            return cachedLoaders[key];
          },
        },
      },
    },
    Tier: {
      ...context.loaders.Tier,
      availableQuantity: new DataLoader(tierIds =>
        sequelize
          .query(
            `
          SELECT t.id, (t."maxQuantity" - COALESCE(SUM(o.quantity), 0)) AS "availableQuantity"
          FROM "Tiers" t
          LEFT JOIN "Orders" o ON o."TierId" = t.id AND o."deletedAt" IS NULL AND o."processedAt" IS NOT NULL AND o."status" NOT IN (?)
          WHERE t.id IN (?)
          AND t."maxQuantity" IS NOT NULL
          AND t."deletedAt" IS NULL
          GROUP BY t.id
        `,
            {
              replacements: [
                [orderStatus.ERROR, orderStatus.CANCELLED, orderStatus.EXPIRED, orderStatus.REJECTED],
                tierIds,
              ],
              type: sequelize.QueryTypes.SELECT,
            },
          )
          .then(results => {
            return tierIds.map(tierId => {
              const result = results.find(({ id }) => id === tierId);
              if (result) {
                return result.availableQuantity > 0 ? result.availableQuantity : 0;
              } else {
                return null;
              }
            });
          }),
      ),
      // Tier - totalDistinctOrders
      totalDistinctOrders: new DataLoader<number, number>(ids =>
        Order.findAll({
          attributes: [
            'TierId',
            [
              sequelize.fn(
                'COALESCE',
                sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('FromCollectiveId'))),
                0,
              ),
              'count',
            ],
          ],
          where: { TierId: { [Op.in]: ids } },
          group: ['TierId'],
        }).then(results =>
          sortResults(ids, results, 'TierId').map(result => (get(result, 'dataValues.count') as number) || 0),
        ),
      ),

      // Tier - totalOrders
      totalOrders: new DataLoader<number, number>(async ids => {
        const results = (await Order.findAll({
          attributes: ['TierId', [sequelize.fn('COALESCE', sequelize.fn('COUNT', sequelize.col('id')), 0), 'count']],
          where: { TierId: { [Op.in]: ids }, processedAt: { [Op.ne]: null } },
          group: ['TierId'],
        })) as unknown as { TierId: number; count: number }[];
        return sortResults(ids, results, 'TierId').map(result => get(result, 'dataValues.count') || 0);
      }),

      // Tier - totalActiveDistinctOrders
      totalActiveDistinctOrders: new DataLoader<number, number>(ids =>
        Order.findAll({
          attributes: [
            'TierId',
            [
              sequelize.fn(
                'COALESCE',
                sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.col('FromCollectiveId'))),
                0,
              ),
              'count',
            ],
          ],
          where: { TierId: { [Op.in]: ids }, processedAt: { [Op.ne]: null }, status: { [Op.in]: ['ACTIVE', 'PAID'] } },
          group: ['TierId'],
        }).then(results =>
          sortResults(ids, results, 'TierId').map(result => (get(result, 'dataValues.count') as number) || 0),
        ),
      ),

      // Tier - totalDonated
      totalDonated: new DataLoader<number, number>(ids =>
        sequelize
          .query(
            `
        SELECT "Order"."TierId", COALESCE(SUM("Transaction"."netAmountInCollectiveCurrency"), 0) AS "totalDonated"
        FROM "Transactions" AS "Transaction"
        INNER JOIN "Orders" AS "Order" ON "Transaction"."OrderId" = "Order"."id"
          AND "Order"."deletedAt" IS NULL
          -- the following would make the query slow
          -- replaced by "kind" condition for the same effect
          -- AND "Transaction"."CollectiveId" = "Order"."CollectiveId"
        WHERE "Order"."TierId" IN (?)
        AND "Transaction"."deletedAt" IS NULL
        AND "Transaction"."RefundTransactionId" IS NULL
        AND "Transaction"."type" = 'CREDIT'
        AND "Transaction"."kind" IN ('CONTRIBUTION', 'ADDED_FUNDS')
        GROUP BY "Order"."TierId";
      `,
            {
              replacements: [ids],
              type: sequelize.QueryTypes.SELECT,
            },
          )
          .then(results => sortResults(ids, results, 'TierId').map(result => (result ? result['totalDonated'] : 0))),
      ),

      // Tier - totalMonthlyDonations
      totalMonthlyDonations: new DataLoader<number, number>(ids =>
        sequelize
          .query(
            `
        SELECT o."TierId" AS "TierId", COALESCE(SUM(s."amount"), 0) AS "total"
        FROM "Orders" o
        INNER JOIN "Subscriptions" s ON o."SubscriptionId" = s.id
        WHERE o."TierId" IN (?)
        AND o."deletedAt" IS NULL
        AND s."isActive" = TRUE
        AND s."interval" = 'month'
        GROUP BY "TierId";
      `,
            {
              replacements: [ids],
              type: sequelize.QueryTypes.SELECT,
            },
          )
          .then(results => sortResults(ids, results, 'TierId').map(result => (result ? result['total'] : 0))),
      ),

      // Tier - totalYearlyDonations
      totalYearlyDonations: new DataLoader<number, number>(ids =>
        sequelize
          .query(
            `
        SELECT o."TierId" AS "TierId", COALESCE(SUM(s."amount"), 0) AS "total"
        FROM "Orders" o
        INNER JOIN "Subscriptions" s ON o."SubscriptionId" = s.id
        WHERE o."TierId" IN (?)
        AND o."deletedAt" IS NULL
        AND s."isActive" = TRUE
        AND s."interval" = 'year'
        GROUP BY "TierId";
      `,
            {
              replacements: [ids],
              type: sequelize.QueryTypes.SELECT,
            },
          )
          .then(results => sortResults(ids, results, 'TierId').map(result => (result ? result['total'] : 0))),
      ),

      // Tier - totalRecurringDonations
      totalRecurringDonations: new DataLoader<number, number>(ids => {
        return sequelize
          .query(
            `
          SELECT o."TierId" AS "TierId",
          COALESCE(
            SUM(
              CASE
                WHEN s."interval" = 'year'
                  THEN s."amount"/12
                ELSE s."amount"
              END
            ), 0)
          AS "total"
          FROM "Orders" o
          INNER JOIN "Subscriptions" s ON o."SubscriptionId" = s.id
          WHERE o."TierId" IN (?)
          AND o."deletedAt" IS NULL
          AND s."isActive" = TRUE
          AND s."interval" IN ('year', 'month')
          GROUP BY "TierId";
      `,
            {
              replacements: [ids],
              type: sequelize.QueryTypes.SELECT,
            },
          )
          .then(results =>
            sortResults(ids, results, 'TierId').map(result => (result ? (result['total'] as number) : 0)),
          );
      }),

      // Tier - contributorsStats
      contributorsStats: new DataLoader<
        number,
        { id: number; all: number; USER: number; ORGANIZATION: number; COLLECTIVE: number }
      >(async tiersIds => {
        const results = (await Member.findAll({
          attributes: [
            'TierId',
            sequelize.col('memberCollective.type'),
            [sequelize.fn('COUNT', sequelize.col('memberCollective.id')), 'count'],
          ],
          where: {
            TierId: { [Op.in]: tiersIds },
          },
          group: ['TierId', sequelize.col('memberCollective.type')],
          include: [
            {
              model: Collective,
              as: 'memberCollective',
              attributes: [],
              required: true,
            },
          ],
          raw: true,
        })) as unknown as Array<{
          TierId: number;
          type: string;
          count: number;
        }>;

        // Used to initialize stats or for when there's no entry available
        const getDefaultStats = TierId => ({
          id: TierId,
          all: 0,
          USER: 0,
          ORGANIZATION: 0,
          COLLECTIVE: 0,
        });

        // Build a map like { 42: { id: 42, users: 12, ... } }
        const resultsMap = {};
        results.forEach(({ TierId, type, count }) => {
          if (!resultsMap[TierId]) {
            resultsMap[TierId] = getDefaultStats(TierId);
          }

          resultsMap[TierId][type] = count;
          resultsMap[TierId].all += count;
        });

        // Return a sorted list to match dataloader format
        return tiersIds.map(tierId => resultsMap[tierId] || getDefaultStats(tierId));
      }),
    },
    PaymentMethod: {
      ...context.loaders.PaymentMethod,
      // PaymentMethod - findByCollectiveId
      findByCollectiveId: new DataLoader<number, PaymentMethod[]>(async CollectiveIds => {
        const results = await PaymentMethod.findAll({
          where: {
            CollectiveId: { [Op.in]: CollectiveIds },
            name: { [Op.ne]: null },
            archivedAt: null,
            expiryDate: {
              [Op.or]: [null, { [Op.gte]: moment().subtract(6, 'month') }],
            },
          },
          order: [['id', 'DESC']],
        });
        return sortResults(CollectiveIds, results, 'CollectiveId', []) as PaymentMethod[][];
      }),
    },
    Order: {
      ...context.loaders.Order,
      // Order - findByMembership
      findByMembership: new DataLoader<string, Order[]>(combinedKeys =>
        Order.findAll({
          where: {
            CollectiveId: { [Op.in]: combinedKeys.map(k => k.split(':')[0]) },
            FromCollectiveId: {
              [Op.in]: combinedKeys.map(k => k.split(':')[1]),
            },
          },
          order: [['createdAt', 'DESC']],
        }).then(results => sortResults(combinedKeys, results, 'CollectiveId:FromCollectiveId', []) as Order[][]),
      ),

      // Order - stats
      stats: {
        transactions: new DataLoader<number, number>(ids =>
          Transaction.findAll({
            attributes: ['OrderId', [sequelize.fn('COALESCE', sequelize.fn('COUNT', sequelize.col('id')), 0), 'count']],
            where: { OrderId: { [Op.in]: ids } },
            group: ['OrderId'],
          }).then(results => sortResults(ids, results, 'OrderId').map(result => get(result, 'dataValues.count') || 0)),
        ),
        totalTransactions: new DataLoader<number, number>(keys =>
          Transaction.findAll({
            attributes: ['OrderId', [sequelize.fn('SUM', sequelize.col('amount')), 'totalAmount']],
            where: { OrderId: { [Op.in]: keys } },
            group: ['OrderId'],
          }).then(results =>
            sortResults(keys, results, 'OrderId').map(result => get(result, 'dataValues.totalAmount') || 0),
          ),
        ),
      },
      // Order - activities
      activities: orderLoaders.generateOrderActivitiesLoader(),
      totalContributed: orderLoaders.generateOrderTotalContributedLoader(),
    },
    Member: {
      ...context.loaders.Member,
      transactions: new DataLoader<string, Transaction[]>(combinedKeys =>
        Transaction.findAll({
          where: {
            CollectiveId: { [Op.in]: combinedKeys.map(k => k.split(':')[0]) },
            FromCollectiveId: {
              [Op.in]: combinedKeys.map(k => k.split(':')[1]),
            },
          },
          order: [['createdAt', 'DESC']],
        }).then(results => sortResults(combinedKeys, results, 'CollectiveId:FromCollectiveId', []) as Transaction[][]),
      ),
      adminUserEmailsForCollective: generateAdminUsersEmailsForCollectiveLoader(),
      isActive: generateMemberIsActiveLoader(req),
      remoteUserIdAdminOfHostedAccount: generateRemoteUserIsAdminOfHostedAccountLoader(req),
      countAdminMembersOfCollective: generateCountAdminMembersOfCollective(),
      remoteUserIsIndirectFinancialContributor: generateRemoteUserIsIndirectFinancialContributor(req),
    },
    SocialLink: {
      ...context.loaders.SocialLink,
      byCollectiveId: new DataLoader<number, SocialLink[]>(async keys => {
        const socialLinks = await SocialLink.findAll({
          where: {
            CollectiveId: { [Op.in]: keys },
          },
          order: [
            ['CollectiveId', 'ASC'],
            ['order', 'ASC'],
          ],
        });

        return sortResultsArray(keys, socialLinks, sl => sl.CollectiveId);
      }),
    },
    Transaction: {
      ...context.loaders.Transaction,
      byOrderId: new DataLoader<number, Transaction[]>(async keys => {
        const where = { OrderId: { [Op.in]: keys } };
        const order = [['createdAt', 'ASC']] as OrderItem[];
        const transactions = await Transaction.findAll({ where, order });
        return sortResults(keys, transactions, 'OrderId', []) as Transaction[][];
      }),
      byExpenseId: new DataLoader<number, Transaction[]>(async keys => {
        const where = { ExpenseId: { [Op.in]: keys } };
        const order = [['createdAt', 'ASC']] as OrderItem[];
        const transactions = await Transaction.findAll({ where, order });
        return sortResults(keys, transactions, 'ExpenseId', []) as Transaction[][];
      }),
      directDonationsFromTo: new DataLoader<{ CollectiveId: number; FromCollectiveId: number }, number>(keys =>
        Transaction.findAll({
          attributes: [
            'FromCollectiveId',
            'CollectiveId',
            [sequelize.fn('SUM', sequelize.col('amount')), 'totalAmount'],
          ],
          where: {
            FromCollectiveId: { [Op.in]: keys.map(k => k.FromCollectiveId) },
            CollectiveId: { [Op.in]: keys.map(k => k.CollectiveId) },
            type: TransactionTypes.CREDIT,
          },
          group: ['FromCollectiveId', 'CollectiveId'],
        }).then(results => {
          const resultsByKey = {};
          results.forEach(r => {
            resultsByKey[`${r.FromCollectiveId}-${r.CollectiveId}`] = r.dataValues['totalAmount'];
          });
          return keys.map(key => {
            return resultsByKey[`${key.FromCollectiveId}-${key.CollectiveId}`] || 0;
          });
        }),
      ),
      totalAmountDonatedFromTo: new DataLoader<{ CollectiveId: number; FromCollectiveId: number }, number>(keys =>
        Transaction.findAll({
          attributes: [
            'FromCollectiveId',
            'UsingGiftCardFromCollectiveId',
            'CollectiveId',
            [sequelize.fn('SUM', sequelize.col('amount')), 'totalAmount'],
          ],
          where: {
            [Op.or]: {
              FromCollectiveId: {
                [Op.in]: keys.map(k => k.FromCollectiveId),
              },
              UsingGiftCardFromCollectiveId: {
                [Op.in]: keys.map(k => k.FromCollectiveId),
              },
            },
            CollectiveId: { [Op.in]: keys.map(k => k.CollectiveId) },
            type: TransactionTypes.CREDIT,
            kind: { [Op.notIn]: ['HOST_FEE', 'HOST_FEE_SHARE', 'HOST_FEE_SHARE_DEBT', 'PLATFORM_TIP_DEBT'] },
            RefundTransactionId: null,
          },
          group: ['FromCollectiveId', 'UsingGiftCardFromCollectiveId', 'CollectiveId'],
        }).then(results => {
          const resultsByKey = {};
          results.forEach(({ CollectiveId, FromCollectiveId, UsingGiftCardFromCollectiveId, dataValues }) => {
            // Credit collective that emitted the gift card (if any)
            if (UsingGiftCardFromCollectiveId) {
              const key = `${UsingGiftCardFromCollectiveId}-${CollectiveId}`;
              const donated = resultsByKey[key] || 0;
              resultsByKey[key] = donated + dataValues['totalAmount'];
            }
            // Credit collective who actually made the transaction
            const key = `${FromCollectiveId}-${CollectiveId}`;
            const donated = resultsByKey[key] || 0;
            resultsByKey[key] = donated + dataValues['totalAmount'];
          });
          return keys.map(key => {
            return resultsByKey[`${key.FromCollectiveId}-${key.CollectiveId}`] || 0;
          });
        }),
      ),
      hostFeeAmountForTransaction: transactionLoaders.generateHostFeeAmountForTransactionLoader(),
      paymentProcessorFeeAmountForTransaction:
        transactionLoaders.generatePaymentProcessorFeeAmountForTransactionLoader(),
      taxAmountForTransaction: transactionLoaders.generateTaxAmountForTransactionLoader(),
      relatedTransactions: transactionLoaders.generateRelatedTransactionsLoader(),
      relatedContributionTransaction: transactionLoaders.generateRelatedContributionTransactionLoader(),
      balanceById: new DataLoader<number, number>(async transactionIds => {
        const transactionBalances = await sequelize.query(
          ` SELECT      id, balance
          FROM        "TransactionBalances"
          WHERE       id in (:transactionIds)`,
          {
            type: sequelize.QueryTypes.SELECT,
            replacements: { transactionIds },
          },
        );

        return sortResultsSimple(transactionIds, transactionBalances);
      }),
    },
    TransactionsImport: {
      ...context.loaders.TransactionsImport,
      stats: generateTransactionsImportStatsLoader(),
      hostStats: generateOffPlatformTransactionsStatsLoader(),
    },
    TransactionsImportRow: {
      ...context.loaders.TransactionsImportRow,
      byExpenseId: new DataLoader<number, TransactionsImportRow>(async expenseIds => {
        const rows = await TransactionsImportRow.findAll({
          where: { ExpenseId: { [Op.in]: expenseIds } },
        });

        return sortResultsSimple(expenseIds, rows, result => result['ExpenseId']);
      }),
      byOrderId: new DataLoader<string, TransactionsImportRow>(async orderIds => {
        const rows = await TransactionsImportRow.findAll({
          where: { OrderId: { [Op.in]: orderIds } },
        });

        return sortResultsSimple(orderIds, rows, result => result['OrderId']);
      }),
    },

    // Non-model loaders
    Contributors: {
      forCollectiveId: contributorsLoaders.forCollectiveId(),
      totalContributedToHost: contributorsLoaders.generateTotalContributedToHost(),
    },
    search: generateSearchLoaders(req),
  };

  return loaders;
};

export function loadersMiddleware(req, res, next) {
  req.loaders = generateLoaders(req);
  next();
}
